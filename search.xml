<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo博客部署到服务器上</title>
      <link href="/posts/8b1381d7.html"/>
      <url>/posts/8b1381d7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hexo博客部署到服务器上"><a href="#Hexo博客部署到服务器上" class="headerlink" title="Hexo博客部署到服务器上"></a>Hexo博客部署到服务器上</h1><p><a href="https://blog.csdn.net/qq_43431158/article/details/104221186">blog.csdn.net</a></p><h3 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h3><h2 id="一、部署博客"><a href="#一、部署博客" class="headerlink" title="一、部署博客"></a>一、部署博客</h2><h4 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h4><p>首先安装<strong>git</strong>和<strong>nginx</strong>，Git 用于版本管理和部署，Nginx 用于静态博客托管。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> update<span class="token function">apt-get</span> <span class="token function">install</span> git-core nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        </p><h6 id="0x01-创建私有-Git-仓库"><a href="#0x01-创建私有-Git-仓库" class="headerlink" title="0x01: 创建私有 Git 仓库"></a>0x01: 创建私有 Git 仓库</h6><p>在 <code>/var/repo/</code> 下，创建一个名为 <code>hexo_static</code> 的裸仓库,然后需要修改用户对目录的权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> /var/repo/<span class="token function">sudo</span> <span class="token function">chown</span> <span class="token parameter variable">-R</span> <span class="token environment constant">$USER</span><span class="token builtin class-name">:</span><span class="token environment constant">$USER</span> /var/repo/<span class="token function">sudo</span> <span class="token function">chmod</span> <span class="token parameter variable">-R</span> <span class="token number">755</span> /var/repo/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        </p><p>然后，执行下面的命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /var/repo/<span class="token function">git</span> init <span class="token parameter variable">--bare</span> hexo_static.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        </p><h6 id="0x02-配置-Nginx-托管文件目录"><a href="#0x02-配置-Nginx-托管文件目录" class="headerlink" title="0x02:配置 Nginx 托管文件目录"></a>0x02:配置 Nginx 托管文件目录</h6><p>创建 <code>/var/www/hexo</code> 目录，用于 Nginx 托管</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /var/www/hexo<span class="token comment">#修改目录的所有权和权限</span><span class="token function">sudo</span> <span class="token function">chown</span> <span class="token parameter variable">-R</span> <span class="token environment constant">$USER</span><span class="token builtin class-name">:</span><span class="token environment constant">$USER</span> /var/www/hexo<span class="token function">sudo</span> <span class="token function">chmod</span> <span class="token parameter variable">-R</span> <span class="token number">755</span> /var/www/hexo<span class="token comment">#修改 Nginx 的 default 设置</span><span class="token function">sudo</span> <span class="token function">vim</span> /etc/nginx/sites-available/default<span class="token punctuation">..</span>.server <span class="token punctuation">{</span>    listen <span class="token number">80</span> default_server<span class="token punctuation">;</span>    listen <span class="token punctuation">[</span>::<span class="token punctuation">]</span>:80 default_server<span class="token punctuation">;</span>    root /var/www/hexo<span class="token punctuation">;</span> <span class="token comment"># 需要修改的部分</span>    index index.html index.htm<span class="token punctuation">;</span><span class="token punctuation">..</span>.将其中的 root 指令指向 /var/www/hexo 目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        </p><p><img src="https://minio.zwj326.space/MyBlog/5dd004bf-1e34-bec0-4681-896d460aecf9.png">-<br>修改完成之后，重启 <code>Nginx</code> 服务，使改动生效</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">service</span> nginx restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        </p><h6 id="0x03-创建-Git-钩子"><a href="#0x03-创建-Git-钩子" class="headerlink" title="0x03:创建 Git 钩子"></a>0x03:创建 Git 钩子</h6><p>在服务器上的裸仓库 <code>hexo_static</code> 创建一个钩子，在满足特定条件时将静态 <code>HTML</code> 文件传送到 Web 服务器的目录下，即 <code>/var/www/hexo</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#在自动生成的 `hooks` 目录下创建一个新的钩子文件</span><span class="token function">vim</span> /var/repo/hexo_static.git/hooks/post-receive<span class="token comment">#在此文件中添加两行代码，指定 Git 的工作树（源代码）和 Git 目录（配置文件等）</span><span class="token comment">#!/bin/bash</span><span class="token function">git</span> --work-tree<span class="token operator">=</span>/var/www/hexo --git-dir<span class="token operator">=</span>/var/repo/hexo_static.git checkout <span class="token parameter variable">-f</span><span class="token comment">#保存退出文件后，需要让该文件变为可执行文件。</span><span class="token function">chmod</span> +x /var/repo/hexo_static.git/hooks/post-receive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        </p><p>如果以上都配置好后，服务器端的配置基本就结束了，下面就开始配置本地的<a href="https://so.csdn.net/so/search?q=Hexo&amp;spm=1001.2101.3001.7020">Hexo</a></p><h4 id="本地Hexo配置"><a href="#本地Hexo配置" class="headerlink" title="本地Hexo配置"></a>本地Hexo配置</h4><h6 id="0x01-修改URL"><a href="#0x01-修改URL" class="headerlink" title="0x01:修改URL"></a>0x01:修改URL</h6><p>之所以配置本地Hexo是为了自动部署到服务器端的 <code>hexo_static</code> 裸仓库中，<code>_config.yml</code> 为 Hexo 的主配置文件。首先需要修改的便是博客的 <code>URL</code> 地址-<br><img src="https://minio.zwj326.space/MyBlog/a782ddaa-d512-3f31-72d5-92abb7434526.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># URL</span><span class="token comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span>url: http://server-ip <span class="token comment"># 没有绑定域名时填写服务器的实际 IP 地址。</span>root: /permalink: :year/:month/:day/:title/permalink_defaults:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        </p><h6 id="0x02-Git-部署"><a href="#0x02-Git-部署" class="headerlink" title="0x02: Git 部署"></a>0x02: Git 部署</h6><p>编辑 <code>_config.yml</code> 文件，修改<code>Deployment</code> 部分</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">deploy:    type: <span class="token function">git</span>    repo: root@云服务器的IP地址:/var/repo/hexo_static    branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        </p><p><img src="https://minio.zwj326.space/MyBlog/b74b2d35-df33-9a62-bc08-689dbf0fabf1.png">-<br>如果到这一步了，那基本就结束了</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hexo g <span class="token operator">&amp;&amp;</span> hexo d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        </p><p>但是还是会遇到一些问题，如：在部署时会遇到（这里借用别人的图）-<br><img src="https://minio.zwj326.space/MyBlog/a8ada695-6bc9-b8f2-4ade-28155d77c2e5.png">-<br>就类似这种问题，解决方法网上也有，只不过让人看的很晕，还好查到了一位大神的博客，出现这个问题的原因在于,第一次使用<code>SSH</code>连接时，会生成一个认证，储存在客户端的<code>known_hosts</code>中，解决方法就是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-R</span> 服务器端的ip地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        </p><p>这样就可以将报错提示的那行给删掉了，从而可以进行正常的连接</p><pre><code>hexo g &amp;&amp; hexo d</code></pre><p>​        </p><p>如果出现这样显示，那就是已经部署好了-<br><img src="https://minio.zwj326.space/MyBlog/1d909af3-4a5a-33bc-c07c-4507f736972f.png"></p><p>这篇文章大多数操作都是模仿这位大师傅，如果哪里叙述的不是很详细可以参考这位师傅的-<br><a href="https://cloud.tencent.com/developer/article/1004587">在 Ubuntu 14.04 服务器上部署 Hexo 博客</a></p><hr><p>—————————————————更新一下————————————-——————</p><hr><h2 id="二、部署到docker中"><a href="#二、部署到docker中" class="headerlink" title="二、部署到docker中"></a>二、部署到docker中</h2><p>虽然都是静态内容已经很安全了，但为了方便管理还是把博客放到docker里面，这里记录一下如何放的。</p><p>先搜索一下含有nginx服务的centos7镜像并拉取</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> search centos7-nginx<span class="token function">docker</span> pull centos7-nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        </p><p><img src="https://minio.zwj326.space/MyBlog/dd2ea5e9-185b-8448-2e25-60136f976e61.png">-<br>映射好端口并建好容器数据卷，方便数据在主机和docker容器的传输</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8888</span>:80  <span class="token parameter variable">-v</span> /var/www/hexo:/var/www/hexo  7f9e697422eb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        </p><p>接下来进入docker容器中，修改一下nginx的配置</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vi</span> /etc/nginx/conf.d/default.conf <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        </p><p><img src="https://minio.zwj326.space/MyBlog/e1254cfb-9d96-516f-aa09-3a8985bba867.png">-<br>修改好之后就可以退出docker容器了，接下来在主机中进行操作</p><p>在 <code>/var/repo/</code> 下，创建一个名为 <code>hexo_static</code> 的裸仓库,然后需要修改用户对目录的权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">mkdir</span> /var/repo/<span class="token function">sudo</span> <span class="token function">chown</span> <span class="token parameter variable">-R</span> <span class="token environment constant">$USER</span><span class="token builtin class-name">:</span><span class="token environment constant">$USER</span> /var/repo/<span class="token function">sudo</span> <span class="token function">chmod</span> <span class="token parameter variable">-R</span> <span class="token number">755</span> /var/repo/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        </p><p>然后，执行下面的命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /var/repo/<span class="token function">git</span> init <span class="token parameter variable">--bare</span> hexo_static.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        </p><p>修改<code>/var/www/hexo</code>目录的所有权和权限</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">chown</span> <span class="token parameter variable">-R</span> <span class="token environment constant">$USER</span><span class="token builtin class-name">:</span><span class="token environment constant">$USER</span> /var/www/hexo<span class="token function">sudo</span> <span class="token function">chmod</span> <span class="token parameter variable">-R</span> <span class="token number">755</span> /var/www/hexo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>​        </p><p>在服务器上的裸仓库 <code>hexo_static</code> 创建一个钩子，在满足特定条件时将静态 <code>HTML</code> 文件传送到 Web 服务器的目录下，即 <code>/var/www/hexo</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#在自动生成的 `hooks` 目录下创建一个新的钩子文件</span><span class="token function">vim</span> /var/repo/hexo_static.git/hooks/post-receive<span class="token comment">#在此文件中添加两行代码，指定 Git 的工作树（源代码）和 Git 目录（配置文件等）</span><span class="token comment">#!/bin/bash</span><span class="token function">git</span> --work-tree<span class="token operator">=</span>/var/www/hexo --git-dir<span class="token operator">=</span>/var/repo/hexo_static.git checkout <span class="token parameter variable">-f</span><span class="token comment">#保存退出文件后，需要让该文件变为可执行文件。</span><span class="token function">chmod</span> +x /var/repo/hexo_static.git/hooks/post-receive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        </p><p>如果以上都配置好后，配置一下本地的Hexo就可以了</p><p>URL要加上映射的端口-<br><img src="https://minio.zwj326.space/MyBlog/2b232822-a692-8bc1-8327-bc45d09f020a.png">-<br>上传的时候不要映射端口，直接上传到本机服务器上，由数据容器卷共享过去-<br><img src="https://minio.zwj326.space/MyBlog/735857ba-0d24-abd4-9234-faf11bab3d44.png">-<br>这样就可以了-</p><p><a href="https://blog.csdn.net/qq_43431158/article/details/104221186">查看原网页: blog.csdn.net</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客趣事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程总结</title>
      <link href="/posts/daba930f.html"/>
      <url>/posts/daba930f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Java多线程总结"><a href="#Java多线程总结" class="headerlink" title="Java多线程总结"></a>Java多线程总结</h1><p><a href="https://blog.csdn.net/wangzq0920/article/details/99730596">blog.csdn.net</a></p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li>线程创建方式</li><li>线程的基本状态以及状态之间的关系？</li><li>线程的sleep()方法和yield()方法有什么区别</li><li>请说明一下sleep() 和 wait() 有什么区别？</li><li>请分析一下同步方法和同步代码块的区别是什么？</li><li>线程的基本状态以及状态之间的关系？</li><li>join()的作用</li><li>synchronized 关键字和 volatile 关键字的区别</li><li>Java的原子性&amp;&amp;可见性&amp;&amp;有序性</li><li>执行execute()方法和submit()方法的区别是什么呢？</li><li>为什么要用线程池？</li><li>如何创建线程池</li><li>线程实现callable接口和runnable接口的区别</li><li>notify()和 notifyAll()有什么区别？</li><li>Java中锁的分类</li><li>volatile关键字</li></ul><h2 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h2><ul><li>继承Thread类</li><li>实现Runnable接口</li></ul><hr><h2 id="线程的基本状态以及状态之间的关系？"><a href="#线程的基本状态以及状态之间的关系？" class="headerlink" title="线程的基本状态以及状态之间的关系？"></a>线程的基本状态以及状态之间的关系？</h2><ul><li>创建：创建进程拥有PCB，但是其它资源还未就绪</li><li>就绪（runable）：其他资源都准备好，就差cpu。线程对象创建后，其他线程(比如 main 线程）调用了该对象 的 start ()方法。</li><li>执行（Running）：也获得了cpu</li><li>阻塞（Block）：其它设备没有就绪从而放弃CPU的使用权</li><li>终止：归还pcb-<br><img src="https://minio.zwj326.space/MyBlog/2bf125e3-52d9-a07a-48a4-f407a72f658c.png"></li></ul><hr><h2 id="线程的sleep-方法和yield-方法有什么区别"><a href="#线程的sleep-方法和yield-方法有什么区别" class="headerlink" title="线程的sleep()方法和yield()方法有什么区别"></a>线程的sleep()方法和yield()方法有什么区别</h2><p>①sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；-<br>② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；-<br>③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；-<br>④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</p><hr><h2 id="请说明一下sleep-和-wait-有什么区别？"><a href="#请说明一下sleep-和-wait-有什么区别？" class="headerlink" title="请说明一下sleep() 和 wait() 有什么区别？"></a>请说明一下sleep() 和 wait() 有什么区别？</h2><ul><li>sleep是线程类（Thread）的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep不会释放对象锁。</li><li>wait是Object类的方法，对此对象调用wait方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。</li></ul><hr><h2 id="请分析一下同步方法和同步代码块的区别是什么？"><a href="#请分析一下同步方法和同步代码块的区别是什么？" class="headerlink" title="请分析一下同步方法和同步代码块的区别是什么？"></a>请分析一下同步方法和同步代码块的区别是什么？</h2><hr><h2 id="线程的基本状态以及状态之间的关系？-1"><a href="#线程的基本状态以及状态之间的关系？-1" class="headerlink" title="线程的基本状态以及状态之间的关系？"></a>线程的基本状态以及状态之间的关系？</h2><ul><li>同步方法默认用this或者当前类class对象作为锁；</li><li>同步代码块可以选择以什么来加锁，比同步方法要更细颗粒度，我们可以选择只同步会发生同步问题的部分代码而不是整个方法。</li></ul><hr><h2 id="join-的作用"><a href="#join-的作用" class="headerlink" title="join()的作用"></a>join()的作用</h2><p>让“主线程”等待“子线程”结束之后才能继续运行。</p><p>在线程A中 调用 线程B<code>对象.join( )</code>方法：</p><ol><li>如果线程B 是可运行态，则线程A阻塞自己运行，直到线程B 运行结束；</li><li>如果线程B 不是可运行状态，则继续执行线程A，并不会执行线程B.。</li></ol><hr><h2 id="synchronized-关键字和-volatile-关键字的区别"><a href="#synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="synchronized 关键字和 volatile 关键字的区别"></a>synchronized 关键字和 volatile 关键字的区别</h2><ul><li>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。</li><li>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</li><li>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</li><li>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</li></ul><hr><h2 id="Java的原子性-amp-amp-可见性-amp-amp-有序性"><a href="#Java的原子性-amp-amp-可见性-amp-amp-有序性" class="headerlink" title="Java的原子性&amp;&amp;可见性&amp;&amp;有序性"></a>Java的原子性&amp;&amp;可见性&amp;&amp;有序性</h2><ul><li><strong>原子性</strong>：是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么就都不执行。<ul><li>synchronized可以保证原子性</li><li>x=10是原子性</li><li>i++不是原子性</li><li>y=x不是原子性</li></ul></li><li><strong>可见性</strong>：当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。<ul><li>volatile可以保证</li><li>synchronized可以保证</li><li>Lock</li></ul></li><li><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行。<ul><li>volatile</li><li>synchronized</li><li>Lock</li></ul></li></ul><hr><h2 id="执行execute-方法和submit-方法的区别是什么呢？"><a href="#执行execute-方法和submit-方法的区别是什么呢？" class="headerlink" title="执行execute()方法和submit()方法的区别是什么呢？"></a>执行execute()方法和submit()方法的区别是什么呢？</h2><ul><li>execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</li><li>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值。</li></ul><hr><h2 id="为什么要用线程池？"><a href="#为什么要用线程池？" class="headerlink" title="为什么要用线程池？"></a>为什么要用线程池？</h2><ul><li><strong>降低资源消耗</strong>。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><hr><h2 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h2><ul><li><p>FixedThreadPool ：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolDemo</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//创建线程池对象</span><span class="token class-name">ExecutorService</span> service <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//包含2个线程对象</span><span class="token comment">//创建Runnable实例对象</span><span class="token class-name">MyRunnable</span> r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//自己创建线程对象的方式</span><span class="token comment">//Thread t = new Thread(r);</span><span class="token comment">//t.start(); ---&gt; 调用MyRunnable中的run()</span><span class="token comment">//从线程池中获取线程对象,然后调用MyRunnable中的run()</span>service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//再获取个线程对象，调用MyRunnable中的run()</span>service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//注意：submit方法调用结束后，程序并不终止，是因为线程池控制了线程的关闭。将使用完的线程又归还到了线程池中</span><span class="token comment">//关闭线程池</span><span class="token comment">//service.shutdown();</span><span class="token punctuation">}</span><span class="token punctuation">}</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>该方法返回一个<strong>固定线程数量</strong>的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</p><ul><li>CachedThreadPool：-<br>该方法返回一个<strong>可根据实际情况调整线程数量</strong>的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li></ul><hr><h2 id="线程实现callable接口和runnable接口的区别"><a href="#线程实现callable接口和runnable接口的区别" class="headerlink" title="线程实现callable接口和runnable接口的区别"></a>线程实现callable接口和runnable接口的区别</h2><ul><li>返回值：Callable有返回值（call()方法），Runnable没有返回值</li><li>异常：<ul><li>Runnable没有容错机制，意味着如果出现异常必须立即处理；</li><li>Callable有容错机制，意味着出现异常之后可以向上抛出</li></ul></li><li>启动方式：<ul><li>Runnable可以通过Thread来启动，也可以通过线程池的execute、submit来处理；</li><li>Callable线程只能通过线程池的submit来处理`</li></ul></li></ul><hr><h2 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify()和 notifyAll()有什么区别？"></a>notify()和 notifyAll()有什么区别？</h2><hr><h2 id="Java中锁的分类"><a href="#Java中锁的分类" class="headerlink" title="Java中锁的分类"></a>Java中锁的分类</h2><p>一、java中锁的分类-<br><strong>1、可重入锁</strong></p><ul><li>锁的重入性：如果某个线程试图获得一个由它自己持有的锁，如果这个请求成功，那么这个锁具有重入性（内置锁具有重入性）；如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</li></ul><p><strong>2、可中断锁</strong></p><ul><li>就是可以相应中断的锁。在Java中，synchronized就不是可中断锁，而Lock是可中断锁。如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</li></ul><p><strong>3、公平锁</strong>（一般情况下非公平锁性能好一些）</p><ul><li>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</li></ul><p><strong>4、读写锁</strong></p><ul><li>读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。　　-<br>ReadWriteLock就是读写锁，它是一个接口，-<br>ReentrantReadWriteLock实现了这个接口。可以通过readLock()获取读锁，通过writeLock()获取写锁。</li></ul><hr><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>保证多线程并发执行时某个线程对数据的修改对其他线程的可见性</p><p><strong>原理：</strong></p><ul><li>使用volatile的时候，数据将会直接被写入主内存，而不会缓存在工作内存，因此针对volatile的关键字修饰的变量的操作，所有线程都是可以看见的</li></ul><p><strong>应用场景：</strong></p><ul><li>写入变量值不依赖当前变量的当前值时</li><li>该变量没有包含在具有其他变量的不变式中。</li></ul><hr><p><a href="https://blog.csdn.net/wangzq0920/article/details/99730596">查看原网页: blog.csdn.net</a></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP的三次握手与四次挥手</title>
      <link href="/posts/7e93f93b.html"/>
      <url>/posts/7e93f93b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="TCP的三次握手与四次挥手"><a href="#TCP的三次握手与四次挥手" class="headerlink" title="TCP的三次握手与四次挥手"></a>TCP的三次握手与四次挥手</h1><p><a href="https://www.cnblogs.com/bj-mr-li/p/11106390.html">www.cnblogs.com</a></p><p><img src="https://minio.zwj326.space/MyBlog/4024a082-e8bf-332c-36b1-9086646e0850.png"></p><p> 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</p><p> 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</p><p> 确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</p><p> 同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</p><p> 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p><p> PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。</p><p><img src="https://minio.zwj326.space/MyBlog/e53f00e4-7718-8087-d512-0b04bd5275ca.png"></p><ul><li><strong>三次握手过程理解</strong></li></ul><p><img src="https://minio.zwj326.space/MyBlog/9602779d-c8f4-0e73-3e87-262232d448ef.png"></p><p>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p><p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p><p>四次挥手过程理解</p><p><img src="https://minio.zwj326.space/MyBlog/597cd3fc-e9c5-52aa-55cd-1c5b48d890c1.png">-<br>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。-<br>2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。-<br>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。-<br>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。-<br>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。-<br>6)服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p><p> <strong>常见面试题</strong>-<br>【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</p><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><p>【问题3】为什么不能用两次握手进行连接？</p><p>答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p><p> 现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><p>【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？</p><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。-<br>-———————<br>作者：青柚_-<br>来源：CSDN-<br>原文：<a href="https://blog.csdn.net/qq/_38950316/article/details/81087809-">https://blog.csdn.net/qq\_38950316/article/details/81087809-</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p><p><a href="https://www.cnblogs.com/bj-mr-li/p/11106390.html">查看原网页: www.cnblogs.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 学科基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 2.0 与HTTP1.1的差别</title>
      <link href="/posts/1ca93706.html"/>
      <url>/posts/1ca93706.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTTP-2-0-与HTTP1-1的差别"><a href="#HTTP-2-0-与HTTP1-1的差别" class="headerlink" title="HTTP 2.0 与HTTP1.1的差别"></a>HTTP 2.0 与HTTP1.1的差别</h1><p><a href="https://blog.csdn.net/qq_41257129/article/details/103432915">blog.csdn.net</a></p><h4 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h4><p>在说HTTP2.0前，先说一说发展到HTTP1.1做了哪些升级。</p><p>推荐好文：<a href="https://www.jianshu.com/p/c5571765eb3e">一文读懂HTTP/2及HTTP/3特性-</a></p><h4 id="HTTP1-1的升级"><a href="#HTTP1-1的升级" class="headerlink" title="HTTP1.1的升级"></a>HTTP1.1的升级</h4><p>目前使用最广泛的HTTP1.1做了哪些重大升级？</p><ul><li><strong>默认长连接</strong>。HTTP1.0也提供长连接，但是默认是短连接，要想长连接必须将头部的connection设置为keep-alive。而HTTP1.1默认开启connection：keep-alive，不用设置。</li><li><strong>强制设置Host请求首部字段</strong>。<strong>Host</strong>字段是HTTP1.1唯一一个强制要求设置的字段。</li><li><strong>管线化（pipelining）</strong>：不用等待响应，就可以发送下一个请求。</li><li><strong>缓存处理的扩展</strong>：HTTP1.1增加的<strong>Cache-control</strong>可以控制缓存行为，并且支持断点续传。</li><li><strong>带宽优化</strong>：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了 ，并且不支持断点续传。HTTP1.1增加了<strong>range</strong>请求头部字段，允许客户端只请求服务器某个对象的一部分资源。返回<strong>206状态码</strong>表示请求一部分资源成功，否则返回200的状态码，并且返回对象的全部资源。</li></ul><p>小结：-<br>在 HTTP/1.1 时代主要增加了：-<br>（1）默认长连接：建立连接后，在一定时间内不会断开，其他请求都可以使用这条连接。-<br>（2）pipelining 管线化：通过这个管道，浏览器的多个请求可以同时发到服务器，但是<strong>服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。</strong></p><h4 id="HTTP1-1的瓶颈"><a href="#HTTP1-1的瓶颈" class="headerlink" title="HTTP1.1的瓶颈"></a>HTTP1.1的瓶颈</h4><p>HTTP1.1有很多优点，但是其标准会使其成为发展的瓶颈。</p><ul><li><strong>队头阻塞（Head of line blocking）</strong>：虽然HTTP1.1支持管线化，允许一次发起多个请求，但是服务器会按照请求的顺序依次响应。<strong>一旦响应某个请求出现了阻塞，那么后面的请求即使已经处理完毕了，仍然需要等待阻塞的请求处理完毕。</strong></li><li><strong>多个TCP连接:</strong> 虽然http1.1支持管道化，但是很多浏览器根本不支持它。（因为它真的很鸡肋）。HTTP1.1的请求并发还是基于多个TCP连接，但建立tcp连接的本较高，比较耗时。</li><li><strong>头部信息冗余，每一次请求都会带上一些相同的首部。头部数据都是以纯文本的形式发送的，通常会给每个请求增加500~800字节的负荷。</strong></li><li><strong>请求只能从客户端开始。客户端不能接受除响之外的指令。</strong></li></ul><h4 id="SPDY时代"><a href="#SPDY时代" class="headerlink" title="SPDY时代"></a>SPDY时代</h4><p>SPDY的出现就是为了消除HTTP1.1协议的瓶颈，它并没有改写HTTP协议， 而是以会话层的形式加入到应用层与传输层之间，控制对数据的流动，但是还是采用HTTP建立通信连接。</p><p>SPDY的设计：-<br><img src="https://minio.zwj326.space/MyBlog/c26a8e92-4159-fdb6-19b8-8fb1f6c1c59a.png"></p><p>使用SPAY协议之后，HTTP协议获得了以下功能：</p><ul><li><p>**多路复用（multiplexing)**：通过单一的TCP连接，可以无限制处理多个HTTP请求。所以请求的处理都在一条TCP连接上完成，因此TCP的处理效率得到提高。解决了（head of line blocking）的问题。</p></li><li><p><strong>请求优先级（request priorityzation)</strong>: SPDY不仅可以无限制的并发处理请求，还可以给请求逐个分配优先级顺序。这样重要的请求就会优先响应。</p></li><li><p><strong>header压缩</strong>：HTTP1.1的头部是冗余的，SPDY协议会采用合适的压缩算法压缩HTTP请求和响应的首部。这样，通信产生的数据包数量和发送的字节数就更少了。</p></li><li><p><strong>推送功能（server push）</strong>：SPDY协议支持服务器主动向客户端推送数据的功能。-<br>到底推送了什么？比如客户端请求了一个index.html文件,服务器会将客户端所需要的资源伴随index.html文件一起发送给客户端，不必等待客户端请求。</p><p>普通的客户端请求：-<br><img src="https://minio.zwj326.space/MyBlog/7b428127-870e-e7d5-a251-2d064e805418.png">-<br>服务器推送：-<br><img src="https://minio.zwj326.space/MyBlog/7edd4e7d-62e0-610c-2f72-efd3fc7ccd9b.png"></p></li></ul><h4 id="HTTP2-0时代"><a href="#HTTP2-0时代" class="headerlink" title="HTTP2.0时代"></a>HTTP2.0时代</h4><h5 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a><a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&amp;spm=1001.2101.3001.7020">二进制</a>分帧层</h5><p>HTTP2.0是SPDY的升级版，它的核心就是在应用层与传输层之间添加一层<strong>二进制分帧层</strong>。<strong>HTTP2.0是二进制协议，他采用二进制格式传输数据而不是1.x的文本格式</strong>。文本格式对计算机解析不友好。</p><p>HTTP2.0设计：-<br><img src="https://minio.zwj326.space/MyBlog/5d954f7c-85b7-1268-3b07-7f84b13f6193.png">-<br>上面的图中清晰的表达了HTTP1.1与HTTP2.0的区别，1.1是以文本格式进行传输，而2.0是将消息分为<strong>两个帧（HEADERS与 DATA两种帧类型）来传输</strong>。并且<strong>每个帧采用二进制编码</strong>。 首部信息被封装在HEADERS帧，实体信息则封装在DATA帧中。</p><ul><li>帧：这个新协议通信的最小单位。</li><li>消息：指HTTP的消息，请求、响应等，由一个或多个帧组成。</li><li>流：是连接中的一个虚拟信道，可承载双向的消息（一个或者多个），每个流都有一个唯一的整数标识符。</li></ul><hr><h5 id="HTTP2-0功能"><a href="#HTTP2-0功能" class="headerlink" title="HTTP2.0功能"></a>HTTP2.0功能</h5><p>与SDPY协议的功能相似：</p><ul><li>多路复用：HTTP2建立一个TCP连接，一个连接上面可以有任意多个流，消息分割成一个或多个帧在流里面传输。帧传输过去之后，在进行重组，形成一个完整的请求和响应。</li></ul><p>这里注意：Steam是乱序的，但同一个Sream里面的帧是按序传输的，二进制帧到达后，对方将Sream ID相同的二进制帧组装成完整的<strong>请求报文</strong> 和<strong>响应报文</strong></p><p><img src="https://minio.zwj326.space/MyBlog/271ee7b2-f5bf-66f7-30fd-a053558d7c7d.png"></p><ul><li><p>请求优先级：为并发的请求设置优先级，重要的请求会先响应。</p></li><li><p>压缩头部：HTTP1.x中采用文本格式传输，每个传输会增加500~800字节的开销。每次请求都要带上向cookie、user-agent这样相同的首部。HTTP采用<strong>HPACK</strong>压缩双来压缩头部。在浏览器与服务器之间：-<br>(1) 维护一份相同的静态字典，包含常见的头部名称，以及常见的头部值-<br>(2) 维护一份相同的动态字典，可以动态的添加内容-<br>(3) 通过静态Huffman编码对传输的首部字段进行编码</p><p>静态字典（一部分）：-<br><img src="https://minio.zwj326.space/MyBlog/0de6b7bf-dc46-576e-820b-515ee25e4af2.png">-<br>所以我们在传输首部字段的时候，例如要传输method:GET，我们只要传输静态字典里面的method:GET对应的<strong>索引值</strong>就可以，一个字节就搞定了。假如像user-agent、cookie这种静态字典里面只有首部名称而没有值的首部，第一次传输需要在静态字典中加入值，值会采用静态Huffman编码来减小体积。</p><p>第一次传输过user-agent之后，浏览器和服务器就会把它添加到自己的动态字典 中，后续的传输就可以只传输一个索引就行了。</p></li><li><p>服务器推送：以SPDY一样，支持服务器主动向客户端推送数据的功能。</p></li></ul><h4 id="HTTP1-1的合并请求是否用于HTTP2-0"><a href="#HTTP1-1的合并请求是否用于HTTP2-0" class="headerlink" title="HTTP1.1的合并请求是否用于HTTP2.0"></a>HTTP1.1的合并请求是否用于HTTP2.0</h4><p>答案是：没有必要。-<br>HTTP2.0采用多路复用，一个TCP连接可以 并行传输多个请求，并且HTTP消息都分解为互不依赖的帧来传输，经典的<strong>队头阻塞的问题</strong>解决了。而HTTP1.1合并请求的原因也是为了防止过多的HTTP请求带来的阻塞问题。现在HTTP2.0已经可以解决这问题，所有合并请求就没有必要了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>HTTP1.0</strong></p><ul><li>无状态、无连接</li></ul><p><strong>HTTP1.1</strong></p><ul><li>持久连接</li><li>管线化</li><li>增加缓存处理（如cache-control）</li><li>增加Host字段、支持断点续传</li></ul><p><strong>HTTP2.0</strong></p><ul><li>二进制分帧层</li><li>多路复用</li><li>头部压缩</li><li>请求优先级</li><li>服务器推送</li></ul><p>参考文章：</p><ul><li><a href="https://www.cnblogs.com/heluan/p/8620312.html">HTTP1.0、HTTP1.1和HTTP2.0的区别</a></li><li><a href="https://juejin.im/post/5c0ce870f265da61171c8c66#heading-4">面试官问：你了解HTTP2.0吗？</a></li><li><a href="https://segmentfault.com/a/1190000013028798?utm_source=tag-newest">HTTP1.0、HTTP1.1和HTTP2.0主要特性对比</a></li></ul><p><a href="https://blog.csdn.net/qq_41257129/article/details/103432915">查看原网页: blog.csdn.net</a></p>]]></content>
      
      
      <categories>
          
          <category> 学科基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页面置换算法</title>
      <link href="/posts/1b3c8b4.html"/>
      <url>/posts/1b3c8b4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="页面置换算法-OPT-FIFO-LRU-CLOCK"><a href="#页面置换算法-OPT-FIFO-LRU-CLOCK" class="headerlink" title="页面置换算法-OPT + FIFO + LRU+CLOCK"></a>页面置换算法-OPT + FIFO + LRU+CLOCK</h1><p><a href="https://blog.csdn.net/wang123456___/article/details/116331334">blog.csdn.net</a></p><h3 id="1-页面置换算法之OPT"><a href="#1-页面置换算法之OPT" class="headerlink" title="1.页面置换算法之OPT"></a>1.<a href="https://so.csdn.net/so/search?q=%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95&amp;spm=1001.2101.3001.7020">页面置换算法</a>之OPT</h3><h5 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h5><p>优先淘汰最长时间内不会被访问的页面，缺页率最小，性能最好，但是无法实现</p><h5 id="1-2-例题"><a href="#1-2-例题" class="headerlink" title="1.2 例题"></a>1.2 例题</h5><p>假设系统为某进程分配三个<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020">内存</a>块，并考虑到有一个页面号引用串。依次访问以下页面：-<br>7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1-<br><img src="https://minio.zwj326.space/MyBlog/55386e1e-bdf7-f318-504e-8365379b0ce4.png">-<br>步骤1：首先页面7进入内存块1-<br>步骤2：还有剩余的内存块，将页面0放入内存块2-<br>步骤3：还有剩余的内存块，将页面1放入内存块3-<br>步骤4：要访问页面2，内存块已经占满，此时进行淘汰。现在内存块中有：7，0，1。优先淘汰最长时间内不会被访问的页面，从当前访问的页面2，往后面进行寻找，最后出现的页面就是要淘汰的。0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1，即第一次找到的为0，第二次找到的为1，第三次找到的为7。因此淘汰的为7。如图用页面2替换页面7。-<br>步骤5：依次进行。。。。</p><h5 id="整个过程缺页中断-x3D-9次，页面置换-x3D-6次，因此缺页时未必发生页面置换。若有空闲内存块就不用页面置换。缺页率-x3D-9-x2F-20-x3D-45"><a href="#整个过程缺页中断-x3D-9次，页面置换-x3D-6次，因此缺页时未必发生页面置换。若有空闲内存块就不用页面置换。缺页率-x3D-9-x2F-20-x3D-45" class="headerlink" title="整个过程缺页中断=9次，页面置换=6次，因此缺页时未必发生页面置换。若有空闲内存块就不用页面置换。缺页率=9/20=45%"></a>整个过程缺页中断=9次，页面置换=6次，因此缺页时未必发生页面置换。若有空闲内存块就不用页面置换。缺页率=9/20=45%</h5><h3 id="2-页面置换算法之FIFO"><a href="#2-页面置换算法之FIFO" class="headerlink" title="2.页面置换算法之FIFO"></a>2.页面置换算法之<a href="https://so.csdn.net/so/search?q=FIFO&amp;spm=1001.2101.3001.7020">FIFO</a></h3><h5 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h5><p>优先淘汰最先进入内存的页面，实现简单，但是性能很差，可能出现belady异常</p><h5 id="2-2-例题"><a href="#2-2-例题" class="headerlink" title="2.2 例题"></a>2.2 例题</h5><p>假设系统为某进程分配三个内存块，并考虑到有一个页面号引用串。依次访问以下页面：-<br>3，2，1，0，3，2，4，3，2，1，0，4-<br><img src="https://minio.zwj326.space/MyBlog/93b3ca98-13c0-f5b9-5308-bde7986c0a13.png">-<br>步骤1：首先页面3进入内存块1-<br>步骤2：还有剩余的内存块，将页面2放入内存块2-<br>步骤3：还有剩余的内存块，将页面1放入内存块3-<br>步骤4：要访问页面0，内存块已经占满，此时进行淘汰。现在内存块中有：3-2-1,页面3是最早进入内存的，优先淘汰。因此用页面0替换页面。（与队列的先进先出类似）-<br>步骤5：依次进行。。。。</p><h5 id="缺页次数-x3D-9次，缺页率-x3D-9-x2F-12-x3D-75"><a href="#缺页次数-x3D-9次，缺页率-x3D-9-x2F-12-x3D-75" class="headerlink" title="缺页次数=9次，缺页率=9/12=75%"></a>缺页次数=9次，缺页率=9/12=75%</h5><h5 id="2-3-Belady异常"><a href="#2-3-Belady异常" class="headerlink" title="2.3 Belady异常"></a>2.3 Belady异常</h5><p>Belady异常：当进程分配的物理块数增大时，缺页次数不减反增的异常现象。-<br>只有FIFO算法产生 Belady异常。</p><h3 id="3-页面置换算法之LRU"><a href="#3-页面置换算法之LRU" class="headerlink" title="3.页面置换算法之LRU"></a>3.页面置换算法之LRU</h3><h5 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1 概念"></a>3.1 概念</h5><p>优先淘汰最近最久没有访问的页面，性能很好，但是需要硬件支持，算法开销大</p><h5 id="3-2-例题"><a href="#3-2-例题" class="headerlink" title="3.2 例题"></a>3.2 例题</h5><p>假设系统为某进程分四个内存块，并考虑到有一个页面号引用串。依次访问以下页面：-<br>1，8，1，7，8，2，7，2，1，8，3，8，2，1，3，1，7，1，3，7-<br><img src="https://minio.zwj326.space/MyBlog/46536eac-a634-dbed-560b-a58a7aa4475b.png">-<br>步骤1：首先页面1进入内存块1-<br>步骤2：还有剩余的内存块，将页面8放入内存块2-<br>步骤3：页面1已经放入内存块1，直接跳过，无需置换-<br>步骤4：还有剩余的内存块，将页面7放入内存块3-<br>步骤5：页面8已经放入内存块2，直接跳过，无需置换-<br>步骤6：还有剩余的内存块，将页面7放入内存块3-<br>步骤6：还有剩余的内存块，将页面2放入内存块4-<br>步骤7：依次，页面7，2，1，8，无需置换-<br>步骤8：要访问页面3，内存块已经占满，此时进行淘汰。优先淘汰最近最久没有访问的页面：首先内存中有页面1，8，7，2。从页面3开始逆向扫描：依次为：8，1，2，7。最后被扫描的为页面7，因此被淘汰。页面3置换了页面7。-<br>步骤9：依次进行。。。</p><h3 id="4-页面置换算法之CLOCK-NRU"><a href="#4-页面置换算法之CLOCK-NRU" class="headerlink" title="4.页面置换算法之CLOCK(NRU)"></a>4.页面置换算法之CLOCK(NRU)</h3><h5 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h5><p>简单的CLOCK算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成个循环队列。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫描)</p><h5 id="4-2-例题"><a href="#4-2-例题" class="headerlink" title="4.2 例题"></a>4.2 例题</h5><p>假设系统为某进程分五个内存块，并考虑到有一个页面号引用串。依次访问以下页面：-<br>1，3，4，2，5，6，3，4，7-<br><img src="https://minio.zwj326.space/MyBlog/835e519c-630d-3bc2-88f3-c45b168567d8.png">-<br>注释：访问位=1：表示最近访问过；访问位=0，表示没有访问过。-<br>步骤1：依次将不重复的页面，加入内存，如图所示(上）。-<br>步骤2：当页面6进行访问时，此时已经没有内存块。进行淘汰：从队首开始扫描（1号页面)-<br>,如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后。如图所示(下）-<br><img src="https://minio.zwj326.space/MyBlog/4f8d7bdc-a3fa-8e1e-19f2-d1a9c0e4d16a.png">-<br>步骤3：再进行第二轮扫描，第一个访问位为0的页面，即被替换掉。因此页面6替换页面1。-<br>步骤4：接下来依次访问3号页，4号页，把其置为1。-<br>步骤5. 访问7号页，由于7号页不在内存中。从步骤3中置换的页面的下一个页面开始，进行扫面，找到一个访问号为0的页号，可以看到是2号页。然后用7号页替换2号页。-<br>步骤6：依次进行。。。-<br><img src="https://minio.zwj326.space/MyBlog/79fa2a45-95ff-6ea1-7fdf-1ec1cad0d74b.png"></p><p><a href="https://blog.csdn.net/wang123456___/article/details/116331334">查看原网页: blog.csdn.net</a></p>]]></content>
      
      
      <categories>
          
          <category> 学科基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jwt基本原理</title>
      <link href="/posts/49869f5e.html"/>
      <url>/posts/49869f5e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h1><p><a href="https://www.cnblogs.com/kaiqinzhang/p/12132702.html">www.cnblogs.com</a></p><p>##1.JWT构成</p><ul><li>头部（header）</li><li>有效载荷（Payload）</li><li>签名（signature）</li></ul><p>##2.header(header是一段json，经过base64编码变成一段字符串，编码前后对比图如图所示：)</p><ul><li>typ:token的类型，这里固定为JWT</li><li>alg：使用的hash算法，例如：HMAC SHA256或者RSA</li></ul><p><img src="https://minio.zwj326.space/MyBlog/9a0b3539-5bad-9e99-cc8a-ed45285f2eb3.png"></p><p>##3.payload</p><ul><li>存储需要传递的信息，如用户ID、用户名等</li><li>还包含元数据，如过期时间、发布人等</li><li>与header不同，payload可以加密</li></ul><p>##4.signature</p><ul><li>对header和payload部分进行签名</li><li>保证token在传输的过程中没有被篡改或者损坏</li></ul><p><img src="https://minio.zwj326.space/MyBlog/06eaedea-4650-6314-693e-bb53a17d8c16.png"></p><p> ##5.JWT工作原理</p><p>客户端通过请求将用户名和密码传给服务端，服务端将用户名和密码进行核对，核对成功后将用户id等其他信息作为jwt的有效载荷（payload）与头部进行base64编码形成jwt（字符串），后端将这段字符串作为登陆成功的返回结果返回给前端。前端将其保存在localstroage或sessionstroage里，退出登录时，删除JWT字符串就可以。</p><p>每次请求，前端都会把JWT作为authorization请求头传给后端，后端进行检查。</p><p><img src="https://minio.zwj326.space/MyBlog/8fed9d0f-60d8-466d-daa3-7f9e9efd8c6a.png"></p><p>##6.简单实现</p><p>安装：npm i jsonwebtoken –save</p><p>在controllers中：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> jsonwebtoken <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'jsonwebtoken'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> User <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'../models/user'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">UserCtl</span> <span class="token punctuation">{</span><span class="token keyword">async</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token parameter">ctx</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ctx<span class="token punctuation">.</span><span class="token function">verifyParams</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  <span class="token comment">//验证参数</span>            <span class="token literal-property property">name</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span><span class="token string">'string'</span><span class="token punctuation">,</span><span class="token literal-property property">required</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token literal-property property">password</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token literal-property property">type</span><span class="token operator">:</span><span class="token string">'string'</span><span class="token punctuation">,</span><span class="token literal-property property">required</span><span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token comment">//验证用户名或密码是否正确</span>        <span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">await</span> User<span class="token punctuation">.</span><span class="token function">findOne</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span>request<span class="token punctuation">.</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>user<span class="token punctuation">)</span><span class="token punctuation">{</span>            ctx<span class="token punctuation">.</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">,</span><span class="token string">"用户名或密码不正确"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        <span class="token keyword">const</span> <span class="token punctuation">{</span> _id<span class="token punctuation">,</span> name<span class="token punctuation">}</span> <span class="token operator">=</span> ctx<span class="token punctuation">.</span>request<span class="token punctuation">.</span>body<span class="token punctuation">;</span>        <span class="token keyword">const</span> token <span class="token operator">=</span> jsonwebtoken<span class="token punctuation">.</span><span class="token function">sign</span><span class="token punctuation">(</span><span class="token punctuation">{</span> _id<span class="token punctuation">,</span> name<span class="token punctuation">}</span><span class="token punctuation">,</span> secret<span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token literal-property property">expiresIn</span><span class="token operator">:</span><span class="token string">'1d'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//生成token，expiresIn:过期时间（1天）</span>        ctx<span class="token punctuation">.</span>body <span class="token operator">=</span> <span class="token punctuation">{</span>token<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span>module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserCtl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>##7.附赠一个小技巧哦：</p><p>当我们登录完，后端传给前端token，前端再请求其他接口时需要携带这个token，一般我们是放在请求头里，这个在postman上请求接口时怎么操作呢？</p><p>方法一：我们直接在header中添加。注意：内容为“Bearer”+空格+token ，不要问为什么，如下图：</p><p><img src="https://minio.zwj326.space/MyBlog/a3caa2d8-3508-afee-012a-4f1dc03e7f6b.png"></p><p>方法二：简单一点，我们选择“Authorization“，type选择“bearer token“，并填写token，如下图：</p><p><img src="https://minio.zwj326.space/MyBlog/b23c3a17-4b14-267c-4e23-ca11ded4ffe4.png"></p><p> 但这个样子还是有一丢丢麻烦，因为token总是过期，过几天我们又要手动更换，这时我们可以设置一个全局变量：</p><p>在登录的接口中这样设置一个全局变量，看不懂的可以参考右下角的例子，具体的我也还没有研究：</p><p><img src="https://minio.zwj326.space/MyBlog/0675cbd4-dd67-1b56-b361-8a562e2c5b3b.png"></p><p>然后刚刚引入token的地方，改成引入变量token就可以了</p><p><img src="https://minio.zwj326.space/MyBlog/23a2ec8f-d3a7-b712-104d-eb4630d9d788.png"></p><p><a href="https://www.cnblogs.com/kaiqinzhang/p/12132702.html">查看原网页: www.cnblogs.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Jwt </tag>
            
            <tag> Token </tag>
            
            <tag> Vue </tag>
            
            <tag> Api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka基本原理</title>
      <link href="/posts/2f0e.html"/>
      <url>/posts/2f0e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="kafka基本原理"><a href="#kafka基本原理" class="headerlink" title="kafka基本原理"></a>kafka基本原理</h1><p><a href="https://blog.csdn.net/khuangliang/article/details/107776046">blog.csdn.net</a></p><h2 id="一、kafka概述"><a href="#一、kafka概述" class="headerlink" title="一、kafka概述"></a>一、<a href="https://so.csdn.net/so/search?q=kafka&amp;spm=1001.2101.3001.7020">kafka</a>概述</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>kafka是一个<a href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&amp;spm=1001.2101.3001.7020">分布式</a>的基于发布订阅模式的消息队列，主要用于大数据实时处理灵越</p><h3 id="2、消息队列"><a href="#2、消息队列" class="headerlink" title="2、消息队列"></a>2、<a href="https://so.csdn.net/so/search?q=%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&amp;spm=1001.2101.3001.7020">消息队列</a></h3><h4 id="【1】应用场景"><a href="#【1】应用场景" class="headerlink" title="【1】应用场景"></a>【1】应用场景</h4><p>用于异步、削峰、解耦</p><p><img src="https://minio.zwj326.space/MyBlog/ba1834db-d66c-7d0a-7a33-d9bbbaa6d757.png"></p><h4 id="【2】两种模式"><a href="#【2】两种模式" class="headerlink" title="【2】两种模式"></a>【2】两种模式</h4><h5 id="（1）点对点模式"><a href="#（1）点对点模式" class="headerlink" title="（1）点对点模式"></a>（1）点对点模式</h5><p> 一对一，消费者主动拉取数据。消息生产者将消息发送到queue中，然后消费者从queue中取出并消费消息，消息被消费者消费以后，queue中不在存储消息，所以消息消费者不可能重复消费已经被消费过的消息。queue支持存在多个消费者，即一个消费者组可以有多个消费者，但是消息只能被一个消费者消费。</p><p><img src="https://minio.zwj326.space/MyBlog/17e74f42-f0c4-21f8-5093-8217383be9c0.png"></p><h5 id="（2）发布订阅模式"><a href="#（2）发布订阅模式" class="headerlink" title="（2）发布订阅模式"></a>（2）发布订阅模式</h5><p>一对多，消费者消费数据之后不会清楚消息数据</p><p>消息生成者发布者将消息发布到topic中，同时有多个消息消费者订阅消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。</p><p><img src="https://minio.zwj326.space/MyBlog/2aa35ba6-cab5-4f9f-1540-9c4b839352db.png"></p><h2 id="二、kafka基础架构"><a href="#二、kafka基础架构" class="headerlink" title="二、kafka基础架构"></a>二、kafka基础架构</h2><h3 id="1、架构介绍"><a href="#1、架构介绍" class="headerlink" title="1、架构介绍"></a>1、架构介绍</h3><p> kafka架构 由producer、consumer group、broker组成，producer是消息的生产者，consumer是消息的消费者，broker是代理服务器，消息都存放在broker上。producer、consumer要想向kafka发送和消费数据需要先申请一个主题，都是面向主题进行操作，申请创建topic的时候需要指定分区的个数，副本的个数，kafka集群会采用轮询或者range分区的方式将分区分散到不同的broker上。</p><p>为了方便扩展，提高吞吐量，一个topic分为多个partition</p><p>配合分区的设计，提出消费者组的概念，组内每个消费者并行消费</p><p>为提高可用性，每个partition增加若干副本，类似于namenode Ha结构</p><p><img src="https://minio.zwj326.space/MyBlog/e23e819e-2d8d-226a-c369-da20337e87ff.png"></p><h3 id="2、角色介绍"><a href="#2、角色介绍" class="headerlink" title="2、角色介绍"></a>2、角色介绍</h3><p>producer ： 消息的生产者，向kafka broker发送消息</p><p>consumer ：消息的消费者，从broker拉去消息进行消费</p><p>consumergroup ：消费者组，一个消费者组里可以有多个消费者，组内每个消费者可以负责消费topic不同分区的数据，可以并行消费，一个消费者组逻辑上是一个订阅者。</p><p>broker ：kafka代理，即kafka代理服务器，一个集群由多个broker组成，一个broker可以容纳多个topic。</p><p>topic ： 主题，可以理解成队列，但是和点对点队列不同的是，不同的消费者组都可以从topic拉去相同的消息。</p><p>由此引出推模型和拉模型的区别：</p><p>推模型 push ：指定消息推送给谁，如果要给多个对象推送的话，需要推送多份。</p><p>拉模型 pull ：消息发布出去，放到某个地方，感兴趣的自己来拉。只需要推一份数据。</p><p>partition ： 分区，为了实现扩展性，一个非常大的topic可以分布到多个broker上，一个topic分为多个partition提高消息的发送和消费的速度，可以将一个partition看成一个有序的队列。</p><p>replica ： 副本，为了保证集群中某个节点发生故障时，该节点上的partition数据不丢失，且kafka仍然能继续工作，kafka提供了副本机制，一个topic的每个分区都有若干个副本，一个leader和若干个follower。</p><p>leader ： 每个分区多个副本的master，生产者、消费者消息发送和消费的对象都是和leader进行通信。</p><p>follower ： 每个分区多个副本中的slave，实时从leader中同步数据，保持和leader数据的同步。leader发生故障时，某个follower会成为新的leader。</p><h2 id="三、kafka工作流程和文件存储机制"><a href="#三、kafka工作流程和文件存储机制" class="headerlink" title="三、kafka工作流程和文件存储机制"></a>三、kafka工作流程和文件存储机制</h2><h3 id="1、工作流程"><a href="#1、工作流程" class="headerlink" title="1、工作流程"></a>1、工作流程</h3><p><img src="https://minio.zwj326.space/MyBlog/a6a3c4a7-178d-ca66-5841-83f7530e9c6b.png"></p><h3 id="2、存储机制"><a href="#2、存储机制" class="headerlink" title="2、存储机制"></a>2、存储机制</h3><p>kafka中的消息是以topic进行分类的，消息的生产者生产消息，消息的消费者消费消息都是面向topic的。</p><p> topic是逻辑上的概念，而partition是物理上的概念，一个partition对应一个log文件，producer每次生产的消息都会追加到该文件的末尾。</p><p> 由于每次生产者生产消息都会追加到log文件中，为了防止日志文件过大影响消息的查找定位效率，kafka引入了分片和索引的机制，将一个partition又分为若干个segment，每个segment包含一个存储数据的log文件和查找的index索引文件，这些文件位于一个文件夹下，文件夹的命名规则为topic名称+分区序号。</p><p><img src="https://minio.zwj326.space/MyBlog/8bf83dbe-ac15-b136-90dc-3093c3773709.png"></p><p>log文件和index文件以该segment的第一条消息的offset命名。下图展示了如何根据offset来查找对应的消息。</p><p><img src="https://minio.zwj326.space/MyBlog/3660ee25-e92f-3c62-0f4c-f5e2433a7f0e.png"></p><p><img src="https://minio.zwj326.space/MyBlog/ea191513-64c7-386f-9894-960d91080286.png"></p><p> 更具offset找到index文件，在index文件中找到该offset消息在消息文件中的结束位置，根据上一条消息的结束位置和本条消息的结束位置就能得到该消息。</p><h2 id="四、kafka生产者"><a href="#四、kafka生产者" class="headerlink" title="四、kafka生产者"></a>四、kafka生产者</h2><h3 id="1、分区选择策略"><a href="#1、分区选择策略" class="headerlink" title="1、分区选择策略"></a>1、分区选择策略</h3><h4 id="【1】分区的原因"><a href="#【1】分区的原因" class="headerlink" title="【1】分区的原因"></a>【1】分区的原因</h4><p>a）方便在集群中扩张，每个partition可以通过调整以适应它所在的机器，而一个topic又可以由多个partition组成，因此整个集群就可以适应任意大小的数据了。</p><p>b）可以提高并发，以partition为单位进行读写</p><h4 id="【2】分区的原则"><a href="#【2】分区的原则" class="headerlink" title="【2】分区的原则"></a>【2】分区的原则</h4><p>producer将消息包装成一个producerRecord对象发送出去</p><p>a）指明分区的情况话直接发送给该分区</p><p>b）没指明partition，对象存在key的时候，将key的hashcode对partition数进行取模得到partition值</p><p>c）上面都没指定的时候，第一次调用时随机生成一个整数，后面每次在这个整数上自增，将这个值与topic的partition数取模，得到partition位置，即round-robin算法轮询算法。</p><h3 id="2、数据可靠性保证"><a href="#2、数据可靠性保证" class="headerlink" title="2、数据可靠性保证"></a>2、数据可靠性保证</h3><p> 为了保证producer发送的数据能可靠的发送到指定的topic，topic的每个partition收到producer发送的数据后都需要向producer发送确认消息，即acknowledgement确认收到消息，如果producer收到ack就会进行下一轮的发送，否则重新发送数据。</p><h4 id="【1】数据可靠性问题描述"><a href="#【1】数据可靠性问题描述" class="headerlink" title="【1】数据可靠性问题描述"></a>【1】数据可靠性问题描述</h4><p><img src="https://minio.zwj326.space/MyBlog/17b1c4fb-fefb-db47-7af9-ee16777072a9.png"></p><h4 id="【2】数据可靠性保证的方式"><a href="#【2】数据可靠性保证的方式" class="headerlink" title="【2】数据可靠性保证的方式"></a>【2】数据可靠性保证的方式</h4><p>那么什么partition所在的broker什么时候发送ack给producer？有什么选择方案？</p><p>方式</p><p>问题</p><p>优点</p><p>缺点</p><p>leader落盘后直接返回ack</p><p>如果producer收到ack后leader挂了，follower还未同步成功，造成消息丢失。</p><p>不接受</p><p>不接受</p><p>follower全部同步成功后返回ack</p><p>不存在上面消息丢失的问题。</p><p>leader选举时容忍n台节点故障，需要n+1个副本，随便选一个follower即可。</p><p>高延迟，需要等待follower都同步成功。</p><p>半数以上follower同步成功后返回ack</p><p>不存在上面消息丢失的问题。</p><p>低延迟</p><p>选举新leader时，容忍n台节点故障，需要2n+1个副本。</p><p>leader选举为啥会成为缺点？</p><p>因为需要半数以上的follower同意后才能选出leader，之所以需要半数以上是因为为了避免脑裂的问题SB问题。</p><p>kafka选取哪种方案？</p><p>kafka选择所有follower同步成功后再返回ack的方案，原因如下：</p><p>a–&gt;同样为了容忍n台节点故障，第一种方案需要2n+1个副本，而第二种方案只需要n+1个副本，而kafka每个分区都有大量的数据，第一种方案会造成大量的数据冗余。</p><p>b–&gt;第二种方案的网络延迟虽然比较高，但都是一个局域网中，网络延时的影响也比较小。</p><h4 id="【3】ISR"><a href="#【3】ISR" class="headerlink" title="【3】ISR"></a>【3】ISR</h4><p>kafka怎么解决高延迟的问题？ISR</p><p> 如果一台follower因为某种原因迟迟不能同步数据，那么leader就需要一直等它而不能发送ack，为了解决这个问题，kafka采用了一个ISR方案。</p><p> leader维护了一个动态的in-sync-replica (与leader保持同步的副本集合，该集合中的副本和leader数据是一致的)，当isr中的follower和leader数据同步完成之后，leader就会向follower发送ack，如果isr中的follower长时间未向leader发送同步完成消息，leader会将其从isr中剔除，等待的时长由replica.time.max.ms参数设定。leader故障之后，就会从isr中选举出新的leader。</p><h4 id="【4】acks参数配置"><a href="#【4】acks参数配置" class="headerlink" title="【4】acks参数配置"></a>【4】acks参数配置</h4><p>0：producer不等待broker的ack，这种方式提供了一个最低的延迟，broker一接收到还没写入磁盘就已经返回，当broker故障时可能存在数据丢失。</p><p>1：producer等待broker的ack，partition的leader落盘成功后返回ack，如果follower同步成功之前leader故障，存在数据丢失。</p><p><img src="https://minio.zwj326.space/MyBlog/034bd0a0-f00d-2865-6e7a-1f73e377334c.png"></p><p>-1: producer等待leader、follower全部落盘成功后返回ack，这种情况不存在数据丢失，但是，如果落盘成功后，leader故障还未来得及向producer发送ack，producer认为失败了会重新发送消息。就会造成数据重复。</p><p><img src="https://minio.zwj326.space/MyBlog/10415b8a-7fbc-d654-fb5b-50d3577bc445.png"></p><p>要实现数据不重复，保证exactly-once，kafka需要进行重复判断（幂等），如果已经有该条offset数据就不重新写入了。</p><h4 id="【5】故障处理"><a href="#【5】故障处理" class="headerlink" title="【5】故障处理"></a>【5】故障处理</h4><p><img src="https://minio.zwj326.space/MyBlog/7148d33d-7ac9-f4ac-3d87-462389fc04fb.png"></p><h5 id="（1）follower故障"><a href="#（1）follower故障" class="headerlink" title="（1）follower故障"></a>（1）follower故障</h5><p> follower故障后会被leader踢出ISR，follower故障恢复时，需要恢复到和leader数据保持一致，follower会读取本地磁盘上次记录的HW并截取掉高于HW的offset消息，高于HW的消息重新冲leader同步获取。等follower的LEO大于等于该partition的HW，即follower追上leader后，重新加入到ISR中。</p><p> leader HW 和 LEO之间的数据对consumer是不可见的，因为follower数据还没有同步完成。</p><p> 因此如果一个被剔除出ISR的follower需要恢复，重新加入到ISR中，它需要从它记录的上次HW开始同步leader数据，如果它上次记录的HW和LEO之间还有数据，这部分数据不是有效要丢掉，重新从leader同步，知道它的LEO追上现在leader的HW才能加入到ISR集合中</p><h5 id="（2）leader故障"><a href="#（2）leader故障" class="headerlink" title="（2）leader故障"></a>（2）leader故障</h5><p>leader故障后，从ISR中重新选出一个新的leader，之后，为保证多个副本之间的数据一致性，其余的follower会现将各自的log文件高于HW的部分截掉，然后从新的leader同步数据</p><p> 注意：者只能保证副本之间数据的一致性，并不能保证数据不丢失或者数据不重复。</p><h4 id="【6】exactly-one语义"><a href="#【6】exactly-one语义" class="headerlink" title="【6】exactly one语义"></a>【6】exactly one语义</h4><p> 对于某些比较重要的消息，我们需要保证exactly one，即每条消息被发送且只被发送一次。</p><p> 在kafka 0.11版本之后，kafka引入了幂等性机制，配合acks=-1的at least once语义，实现了从producer到broker的exactly once语义。</p><p> 即 at least once + idempotent = exactly once</p><p>使用时，只需要将enable.idempotent属性设置为true即可。kafka会自动将acks属性设为-1.</p><h3 id="3、消息的发送过程"><a href="#3、消息的发送过程" class="headerlink" title="3、消息的发送过程"></a>3、消息的发送过程</h3><p> kafka的producer发送消息采用的是异步的方式。在消息发送的过程中，涉及到两个线程：main线程和sender线程，以及一个线程共享变量-recordAccumulator。main线程将消息发送给recordAccumulator，sender线程不断从recordAccumulator中拉去消息发送到kafka broker中。</p><p><img src="https://minio.zwj326.space/MyBlog/35d2fd4c-efa5-2a21-e667-347830e2c88f.png"></p><p> 相关参数配置：</p><p> batch.size : 只要数据累计到batch.size 之后，sender才会将这批数据发送出去。</p><p> linger.ms ：如果数据迟迟未达到batch.size, sender等待该事件后会发送数据。</p><h3 id="4、同步发送"><a href="#4、同步发送" class="headerlink" title="4、同步发送"></a>4、同步发送</h3><p> 同步发送指，一条消息发送后会阻塞当前线程，直至返回ack，send方法返回的是一个future对象，因此可以根据future对象的特点，实现同步发送的效果，通过future对象的get方法阻塞主线程。</p><h2 id="五、kafka消费者"><a href="#五、kafka消费者" class="headerlink" title="五、kafka消费者"></a>五、kafka消费者</h2><h3 id="1、消费方式"><a href="#1、消费方式" class="headerlink" title="1、消费方式"></a>1、消费方式</h3><p>consumer采用pull模式从broker中读取数据。</p><p>push模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。</p><p>pull 模式：消费者自己从broker中拉取消息。</p><p>push模式：由broker主动将消息推送给消费者。这种模式的目标是尽可能以最快的速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络堵塞，而pull模式则可以根据consumer的消费能力以适当的速率消费消息。</p><p>pull模式不足之处是，如果kafka没有数据，消费者可能会陷入循环中，一直返回空数据，针对这一点，kafka的消费在消费数据时会传入一个时长参数timeout，如果当前没有数据可供消费，consumer会等待一段时间之后再返回，这段时长即timeout。</p><h3 id="2、分区分配策略"><a href="#2、分区分配策略" class="headerlink" title="2、分区分配策略"></a>2、分区分配策略</h3><p> 一个consumer group中有多个consumer，一个topic有多个partition，所以必然会涉及到partition的分配问题，决定哪个partition由哪个consumer消费的问题。</p><p> kafka有两种分配策略，round-robin 和range</p><h4 id="【1】round-robin"><a href="#【1】round-robin" class="headerlink" title="【1】round-robin"></a>【1】round-robin</h4><p><img src="https://minio.zwj326.space/MyBlog/7178b050-fef7-450b-70b5-c4034474f05c.png"></p><h4 id="【2】range"><a href="#【2】range" class="headerlink" title="【2】range"></a>【2】range</h4><p><img src="https://minio.zwj326.space/MyBlog/0a0fac59-dbd1-e9a2-2eaa-061f51814bf2.png"></p><h3 id="3、offset的维护"><a href="#3、offset的维护" class="headerlink" title="3、offset的维护"></a>3、offset的维护</h3><p> 由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置继续消费，所以consumer需要实时记录自己消费到哪个offset，以便故障恢复后继续消费。</p><p> kafka 0.9版本前，consumer默认将offset保存在zookeeper中，从0.9版本后，consumer默认将offset保存在一个kafka的内置topic中，该topic为__consumer_offsets.</p><p> 因此consumer在消费消息后需要向kafka提交offset，kafka配置了默认提交，也可以通过手动的方式进行提交。</p><h2 id="六、kafka高效读写数据"><a href="#六、kafka高效读写数据" class="headerlink" title="六、kafka高效读写数据"></a>六、kafka高效读写数据</h2><h3 id="1、顺序写磁盘"><a href="#1、顺序写磁盘" class="headerlink" title="1、顺序写磁盘"></a>1、顺序写磁盘</h3><p> kafka的producer生产数据，需要写到log文件中，写的过程是一直追加到文件的末端，为顺序写，官网有数据表明，同样的磁盘，顺序写能达到600M/s,二随机写只要100K/s。这与磁盘的机械结构有关，顺序写之所以块是因为省去了大量磁盘寻址的时间。</p><h3 id="2、零拷贝技术"><a href="#2、零拷贝技术" class="headerlink" title="2、零拷贝技术"></a>2、零拷贝技术</h3><p><img src="https://minio.zwj326.space/MyBlog/31d8c0e1-5147-d7dd-4ffc-7087adef38a6.png"></p><h2 id="七、zookeeper在kafka中的作用"><a href="#七、zookeeper在kafka中的作用" class="headerlink" title="七、zookeeper在kafka中的作用"></a>七、zookeeper在kafka中的作用</h2><p> kafka集群中有一个broker会被选举为controller，负责管理集群broker的上下线，所有topic的分区副本分配和leader选举等工作。</p><p> Controller的管理工作都是依赖于zookeeper的。</p><p>下图展示了topic的partition leader选举过程</p><p><img src="https://minio.zwj326.space/MyBlog/c78391dd-df5d-a3b2-6d1d-26a4f71b48bb.png"></p><h2 id="八、问题"><a href="#八、问题" class="headerlink" title="八、问题"></a>八、问题</h2><p>1、kafka中的ISR、OSR、AR是什么？</p><p>ISR 是和leader保持同步的follower集合（in-asyn-replica），OSR是没和leader保持同步的follower集合（out-asyned-replica），AR 是所有副本（assigned replica）。</p><p>2、kafka中的HW、LEO是什么意思？</p><p>LEO log end offset 是日志文件最后一个message的offset</p><p>HW是高水位，是所有ISR中所有follower log文件中LEO最小的值 ，HW之前的所有数据对consumer 可见，因为所有follower都同步完成了，但是HW到LEO之间的数据对consumer不可见。</p><p>3、kafka是怎么体现消息顺序性的？</p><p>某个分区的消息消费是顺序的，但不同分区之间的消费不是顺序的。</p><p>4、kafka中的分区器、序列化器、拦截器是什么，顺序是什么</p><p> 先执行拦截器，然后执行序列化器，然后执行分区器，然后发送给record accumulator，由send线程从record accumulator拉去消息发送给broker。</p><p> 拦截器中断统计方法在最后执行。</p><p>5、kafka生产者客户端是什么样的,采用了几个线程处理？分别是什么线程</p><p> 由拦截器、序列化器、分区器、record accumulate、sender组成，主要包括两个处理线程主线程和sender线程。</p><p>6、消费者组中消费者个数超过了分区的个数，就会有消费者消费不到数据是否正确？</p><p> 如果是一个topic那么，如果消费者个数超过分区个数那么会存在有消费者消费不到数据的情况，如果是很多topic，那么所有的消费者消费的partition大体是均匀的，最多只会多一个。</p><p>7、消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1？</p><p>offset+1</p><p>8、有哪些情形会造成重复消费？</p><p>a、重复消费主要是消费者消费完后还没来得及提交offset，然后宕机了，下次右从上次记录的offset消费，导致重复消费。</p><p>b、或者leader将消息同步给follower后还未来得及发ack，producer重试了，leader没有设置幂等，就会产生重复数据</p><p>9、哪些情景会造成消息漏消费？</p><p>主要是生产者发送消息时，leader还未同步完成返回ack给生产者，然后宕机了，新的follower成为leader然而没有数据。可以通过acks=-1 实现至少消费一次。</p><p>10、当使用kafka-topic.sh创建或者删除了一个topic后，kafka背后会执行什么逻辑？</p><p> 1）会在zookeeper中的/brokers/topics节点下创建一个新的topic节点，如：/brokers/topics/first_topic</p><p> 2）出发controller的监听程序</p><p> 3）kafka controller负责topic的创建工作，并更新metadata cache</p><p>11、topic的分区数可不可以增加，如果可以怎么增加？</p><p>可以增加扩展</p><pre><code>bin/kafka-topics.sh --zookeeper localhost:2181/kafka --alter --topic topic-config --partitions 3 </code></pre><p>​        </p><p>12、topic的分区数可不可以减少，为什么？</p><p>不可以减少，因为删除分区的数据难以处理，因为要删分区的话，该分区还未处理完的消费，正在处理的消息不好迁移。</p><p>13、kafka有内部topic吗？是什么，干什么用的？</p><p>有，__consumers_offset 主题，用于记录各个partition 消费者提交的offset消费记录。</p><p>14、kafka分区分配是怎么分的？</p><p>可以通过轮询或者range的方式将不同的分区分配到不同的broker上；同时对于一个consumer 组里面的consumer也可以采用上面两种方式分配不同的分区给他们消费。</p><p>15、简述下kafka的日志目录结构？</p><p>kafka日志的文件夹名称=topic_partion 组成，文件夹中包含log、和index两类文件，问价的文件名以该segment的第一个消息的offset命名。</p><p>16、如果指定一个offset，kafka controller怎么找到对应的消息？</p><p>先找index文件，然后在index文件中找到offset对应的消息的位置，然后根据消息的位置去log文件中找到相应的消息。</p><p>17、kafka哪些地方需要选举？这些地方的选举策略又有哪些？</p><p>a）选kafka controller，第一个broker成为controller</p><p>b）分区副本的leader选举，从isr中选一个作为leader。</p><p>18、失效副本是指什么？有哪些应对措施？</p><p>不能与leader保持同步，被踢出isr的follower副本，等它同步数据追上leader中hw时重新加入到isr中。</p><p>19、聊一聊kafka controller的作用？</p><p>管理broker集群，包括创建topic，从zk中获取isr并选举leader，管理broker的上线和下线。</p><p>20、kafka的哪些设计使它如此高性能？</p><p>分区</p><p>顺序写磁盘</p><p>零拷贝</p><p><a href="https://blog.csdn.net/khuangliang/article/details/107776046">查看原网页: blog.csdn.net</a></p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
            <tag> 分布式 </tag>
            
            <tag> 消息中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx反向代理--负载均衡</title>
      <link href="/posts/aef0f02d.html"/>
      <url>/posts/aef0f02d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="nginx反向代理–负载均衡"><a href="#nginx反向代理–负载均衡" class="headerlink" title="nginx反向代理–负载均衡"></a>nginx反向代理–负载均衡</h1><p><a href="https://blog.csdn.net/martin_94/article/details/112323893">blog.csdn.net</a></p><h2 id="Nginx配置详解"><a href="#Nginx配置详解" class="headerlink" title="Nginx配置详解"></a><a href="https://so.csdn.net/so/search?q=Nginx&amp;spm=1001.2101.3001.7020">Nginx</a>配置详解</h2><h2 id="nginx概述"><a href="#nginx概述" class="headerlink" title="nginx概述"></a>nginx概述</h2><p>nginx是一款自由的、开源的、高性能的HTTP服务器和<a href="https://so.csdn.net/so/search?q=%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86&amp;spm=1001.2101.3001.7020">反向代理</a>服务器；同时也是一个IMAP、POP3、SMTP代理服务器；nginx可以作为一个HTTP服务器进行网站的发布处理，另外nginx可以作为反向代理进行负载均衡的实现。</p><p>这里主要通过三个方面简单介绍nginx</p><ul><li>反向代理</li><li>负载均衡</li><li>nginx特点</li></ul><h2 id="1-反向代理"><a href="#1-反向代理" class="headerlink" title="1. 反向代理"></a>1. 反向代理</h2><p>关于代理</p><p>说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；</p><p>此时就设计到两个角色，一个是被代理角色，一个是目标角色，被代理角色通过这个代理访问目标角色完成一些任务的过程称为代理操作过程；如同生活中的专卖店~客人到adidas专卖店买了一双鞋，这个专卖店就是代理，被代理角色就是adidas厂家，目标角色就是用户</p><p><img src="https://minio.zwj326.space/MyBlog/331abb36-61a5-3783-0c57-9fab396b7200.png"></p><p>正向代理</p><p>说反向代理之前，我们先看看正向代理，正向代理也是大家最常接触的到的代理模式，我们会从两个方面来说关于正向代理的处理模式，分别从软件方面和生活方面来解释一下什么叫正向代理</p><p>正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个<a href="https://so.csdn.net/so/search?q=%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8&amp;spm=1001.2101.3001.7020">代理服务器</a>，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p><p>举例图片审核不过 大家自行理解吧</p><p>反向代理</p><p>明白了什么是正向代理，我们继续看关于反向代理的处理方式，举例如我大天朝的某宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了，此时就出现了一个大家耳熟能详的名词：分布式部署；也就是通过部署多台服务器来解决访问人数限制的问题；某宝网站中大部分功能也是直接使用nginx进行反向代理实现的，并且通过封装nginx和其他的组件之后起了个高大上的名字：Tengine，有兴趣的童鞋可以访问Tengine的官网查看具体的信息：<a href="http://tengine.taobao.org/">http://tengine.taobao.org/</a>-<br>那么反向代理具体是通过什么样的方式实现的分布式的集群操作呢，我们先看一个示意图：</p><p><img src="https://minio.zwj326.space/MyBlog/cf23adaa-173f-cb19-984e-3bccb18ec211.png"></p><p>通过上述的图解大家就可以看清楚了，多个客户端给服务器发送的请求，nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，nginx扮演的就是一个反向代理角色</p><p>反向代理，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息！</p><p>项目场景</p><p>通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在在一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向单利服务器，反向代理了多台真实的业务处理服务器。具体的拓扑图如下：</p><p><img src="https://minio.zwj326.space/MyBlog/08dd9d51-cb3f-996c-880d-a5538957f2b6.png"></p><h2 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2. 负载均衡"></a>2. <a href="https://so.csdn.net/so/search?q=%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&amp;spm=1001.2101.3001.7020">负载均衡</a></h2><p>我们已经明确了所谓代理服务器的概念，那么接下来，nginx扮演了反向代理服务器的角色，它是以依据什么样的规则进行请求分发的呢？不用的项目应用场景，分发的规则是否可以控制呢？</p><p>这里提到的客户端发送的、nginx反向代理服务器接收到的请求数量，就是我们说的负载量</p><p>请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则</p><p>所以~将服务器接收到的请求按照规则分发的过程，称为负载均衡。</p><p>负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种，硬件负载均衡也称为硬负载，如F5负载均衡，相对造价昂贵成本较高，但是数据的稳定性安全性等等有非常好的保障，如中国移动中国联通这样的公司才会选择硬负载进行操作；更多的公司考虑到成本原因，会选择使用软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制</p><p><img src="https://minio.zwj326.space/MyBlog/da03bdcc-c844-dfc2-1bed-efc1a728463b.png"></p><p>nginx支持的负载均衡调度算法方式如下：</p><ol><li><p>weight轮询（默认）：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。 这种方式下，可以给不同的后端服务器设置一个权重值（weight），用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。</p></li><li><p>ip_hash：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。</p></li><li><p>fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块</p></li><li><p>url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在nginx作为静态服务器的情况下提高缓存效率。同样要注意nginx默认不支持这种调度算法，要使用的话需要安装nginx的hash软件包<br><a href="https://blog.csdn.net/martin_94/article/details/112323893">查看原网页: blog.csdn.net</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ngnix </tag>
            
            <tag> 服务器部署 </tag>
            
            <tag> 反向代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity工作原理</title>
      <link href="/posts/8e269350.html"/>
      <url>/posts/8e269350.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SpringSecurity工作原理"><a href="#SpringSecurity工作原理" class="headerlink" title="SpringSecurity工作原理"></a>SpringSecurity工作原理</h1><p><a href="https://blog.csdn.net/qq_39368007/article/details/112086797">blog.csdn.net</a></p><h2 id="结构总览"><a href="#结构总览" class="headerlink" title="结构总览"></a>结构总览</h2><ul><li><strong>Spring Security</strong>所解决的问题就是<strong>安全访问控制</strong>，</li></ul><p>而<strong>安全访问控制功能</strong>其实就是<strong>对所有进入系统的请求进行拦截</strong>，校验每个请求是否能够访问它所期望的资源。</p><p>根据前边知识的学习，可以通过Filter或<a href="https://so.csdn.net/so/search?q=AOP&amp;spm=1001.2101.3001.7020">AOP</a>等技术来实现，</p><p>Spring Security对Web资源的保护是<strong>靠Filter实现的</strong>，所以从这个Filter来入手，逐步深入Spring Security原理。-<br>当初始化Spring Security时，会创建一个名为<strong>SpringSecurityFilterChain</strong> 的<strong>Servlet过滤器</strong>，</p><p>类型为org.springframework.security.web.FilterChainProxy，它实现了javax.servlet.Filter，</p><p>因此外部的请求会经过此类，下图是Spring Security过滤器链结构图：</p><p><img src="https://minio.zwj326.space/MyBlog/939ff9e3-1364-4fcb-5303-409e099e77be.png"></p><p><strong>FilterChainProxy是一个代理</strong>，</p><p>真正起作用的是FilterChainProxy中SecurityFilterChain所包含的各个Filter，</p><p>同时这些Filter作为Bean被Spring管理，它们是Spring Security核心，各有各的职责，</p><p>但他们并不直接处理用户的认证，也不直接处理用户的授权，</p><p>而是把它们交给了<strong>认证管理器（AuthenticationManager）</strong>和<strong>决策管理器（AccessDecisionManager）</strong>进行处理，</p><p>下图是FilterChainProxy相关类的UML图示。</p><p><img src="https://minio.zwj326.space/MyBlog/85cc3a65-f554-355c-69de-0cabaf1f76cb.png"></p><p>spring Security功能的实现主要是由一系列过滤器链相互配合完成。</p><p><img src="https://minio.zwj326.space/MyBlog/e1ffea53-e40d-c9f6-39d9-815578e03733.png"></p><p>下面介绍过滤器链中主要的几个过滤器及其作用：-<br><strong>SecurityContextPersistenceFilter</strong> 这个Filter是整个拦截过程的入口和出口（也就是第一个和最后一个拦截器），</p><p> 会在请求开始时从配置好的 SecurityContextRepository 中获取 SecurityContext，</p><p> 然后把它设置给SecurityContextHolder。</p><p> 在请求完成后将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好的 SecurityContextRepository，</p><p> 同时清除 securityContextHolder 所持有的 SecurityContext；-<br><strong>UsernamePasswordAuthenticationFilter</strong> 用于处理来自表单提交的认证。该表单必须提供对应的用户名和密码，</p><p> 其内部还有登录成功或失败后进行处理的 AuthenticationSuccessHandler 和 AuthenticationFailureHandler，这些都可以根据需求做相关改变；-<br><strong>FilterSecurityInterceptor</strong> 是用于保护web资源的，使用AccessDecisionManager对当前用户进行授权访问-<br><strong>ExceptionTranslationFilter</strong> 能够捕获来自 FilterChain 所有的异常，并进行处理。但是它只会处理两类异常：-<br><strong>AuthenticationException</strong> 和 <strong>AccessDeniedException</strong>，其它的异常它会继续抛出。</p><hr><hr><h2 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h2><p><img src="https://minio.zwj326.space/MyBlog/0a8dc8c3-4a89-0886-0a93-8485d8905c45.png"></p><p><img src="https://minio.zwj326.space/MyBlog/58cbde08-b520-aeda-9e12-df03ec4cc2ea.png"></p><p><img src="https://minio.zwj326.space/MyBlog/f8862d72-9885-54c4-fad6-f5ced607628d.png"></p><hr><hr><h2 id="AuthenticationProvider"><a href="#AuthenticationProvider" class="headerlink" title="AuthenticationProvider"></a>AuthenticationProvider</h2><p>通过前面的Spring Security认证流程得知，<strong>认证管理器（AuthenticationManager）</strong>委托<strong>AuthenticationProvider</strong>完成认证工作。-<br><strong>AuthenticationProvider是一个接口</strong>，定义如下：</p><p>​                  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AuthenticationProvider</span> <span class="token punctuation">{</span>   <span class="token class-name">Authentication</span> <span class="token function">authenticate</span><span class="token punctuation">(</span><span class="token class-name">Authentication</span> authentication<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">AuthenticationException</span><span class="token punctuation">;</span>   <span class="token keyword">boolean</span> <span class="token function">supports</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://minio.zwj326.space/MyBlog/380315d6-5ddb-6bcf-e21d-b658f528d9d7.png"></p><p>在<strong>DaoAuthenticationProvider</strong>的基类 <strong>AbstractUserDetailsAuthenticationProvider</strong>发现以下代码：            </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">supports</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> authentication<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token class-name">UsernamePasswordAuthenticationToken</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>authentication<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token class-name">UsernamePasswordAuthenticationToken</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>authentication<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="也就是说当web表单提交用户名密码时，Spring-Security由DaoAuthenticationProvider处理。"><a href="#也就是说当web表单提交用户名密码时，Spring-Security由DaoAuthenticationProvider处理。" class="headerlink" title="也就是说当web表单提交用户名密码时，Spring Security由DaoAuthenticationProvider处理。"></a><strong>也就是说当web表单提交用户名密码时，Spring Security由DaoAuthenticationProvider处理。</strong></h3><hr><hr><p>最后，我们来看一下Authentication(认证信息)的结构，</p><p>它是一个接口，我们之前提到的UsernamePasswordAuthenticationToken就是它的实现之一：</p><p><img src="https://minio.zwj326.space/MyBlog/03763551-89b1-12f6-3f75-3630aa6173f9.png"></p><p>（1）Authentication是spring security包中的接口，直接继承自Principal类，而Principal是位于java.security包中的。它是表示着一个抽象主体身份，任何主体都有一个名称，因此包含一个getName()方法。-<br>（2）getAuthorities()，权限信息列表，默认是GrantedAuthority接口的一些实现类，通常是代表权限信息的一系列字符串。-<br>（3）getCredentials()，凭证信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。-<br>（4）getDetails()，细节信息，web应用中的实现接口通常为 WebAuthenticationDetails，它记录了访问者的ip地址和sessionId的值。-<br>（5）getPrincipal()，身份信息，大部分情况下返回的是UserDetails接口的实现类，UserDetails代表用户的详细信息，</p><p> 那从Authentication中取出来的UserDetails就是当前登录用户信息，它也是框架中的常用接口之一。</p><hr><hr><h3 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h3><p>1）认识UserDetailsService-<br>现在咱们现在知道DaoAuthenticationProvider处理了web表单的认证逻辑，认证成功后既得到一个Authentication(UsernamePasswordAuthenticationToken实现)，里面包含了身份信息（Principal）。</p><p>这个身份信息就是一个Object ，大多数情况下它可以被强转为UserDetails对象。-<br>DaoAuthenticationProvider中包含了一个UserDetailsService实例，它负责根据用户名提取用户信息UserDetails(包含密码)，</p><p>而后DaoAuthenticationProvider会去对比UserDetailsService提取的用户密码与用户提交的密码是否匹配作为认证成功的关键依据，</p><p>因此可以通过将自定义的UserDetailsService 公开为spring bean来定义自定义身份验证。            </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserDetailsService</span> <span class="token punctuation">{</span>   <span class="token class-name">UserDetails</span> <span class="token function">loadUserByUsername</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">UsernameNotFoundException</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>很多人把<strong>DaoAuthenticationProvider</strong>和<strong>UserDetailsService</strong>的职责搞混淆，其实UserDetailsService只负责从特定的地方（通常是数据库）加载用户信息，仅此而已。</p><p>而DaoAuthenticationProvider的职责更大，它完成完整的认证流程，同时会把UserDetails填充至Authentication。</p><p>上面一直提到UserDetails是用户信息，咱们看一下它的真面目：</p><p><img src="https://minio.zwj326.space/MyBlog/5a06506f-fb5b-d50b-7a55-2438ef0053a0.png"></p><p>它和Authentication接口很类似，</p><p>比如它们都拥有username，authorities。Authentication的getCredentials()与UserDetails中的getPassword()需要被区分对待，</p><p>前者是用户提交的密码凭证，后者是用户实际存储的密码，认证-<br>其实就是对这两者的比对。</p><p>Authentication中的getAuthorities()实际是由UserDetails的getAuthorities()传递而形成的。</p><p>还记得Authentication接口中的getDetails()方法吗？其中的UserDetails用户详细信息便是经过了AuthenticationProvider认证之后被填充的。-<br>通过实现UserDetailsService和UserDetails，我们可以完成对用户信息获取方式以及用户信息字段的扩展。-<br>Spring Security提供的InMemoryUserDetailsManager(内存认证)，JdbcUserDetailsManager(jdbc认证)就是UserDetailsService的实现类，主要区别无非就是从内存还是从数据库加载用户。</p><p><a href="https://blog.csdn.net/qq_39368007/article/details/112086797">查看原网页: blog.csdn.net</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> SpringSecurity </tag>
            
            <tag> 微框架 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
